# 이진 트리 (Binary Tree) 표현하기

> 파이썬에서 이진 트리(Binary Tree)는 '배열'과 '객체 참조'를 활용해서 구현할 수 있다.

## 배열로 표현하기

'배열'은 선형 자료구조 인데 반해, '트리'는 계층 자료구조이다.

따라서 배열로 트리를 표현하기 위해서는 다음의 3가지 규칙이 필요하다.


- 루트 노드 인덱스를 1로 정하는 경우
    ```
    1. 루트 노드 : 배열 인덱스 1번에 저장
    2. 왼쪽 자식 노드의 배열 인덱스 : (부모 노드의 배열 인덱스 x 2)
    3. 오른쪽 자식 노드의 배열 인덱스 : (부모 노드의 배열 인게스 x 2 + 1)
    ```
- 루트 노드 인덱스를 0로 정하는 경우
    ```
    1. 루트 노드 : 배열 인덱스 0번에 저장
    2. 왼쪽 자식 노드의 배열 인덱스 : (부모 노드의 배열 인덱스 x 2 + 1)
    3. 오른쪽 자식 노드의 배열 인덱스 : (부모 노드의 배열 인게스 x 2 + 2)
    ```

다만, 트리를 배열로 표현하게 되면 배열내에 빈값이 많이 표현된다. 노드들의 부모-자식 관계를 곱셈 연산하여 인덱스로 활용하기 때문에 실제 노드의 수보다 배열의 공간을 많이 활용할 수 밖에 없다. 즉, 메모리가 낭비된다는 단점이 존재한다.

그렇다고 배열 표현이 나쁜 것 만은 아니다. 

이진트리를 배열로 표현하는 방식은 **구현 난이도가 쉬우므로**, 메모리만 넉넉하다면 구현 시간을 단축하는 용도로 좋다. (N개의 노드를 배열로 표현하는 시간 복잡도는 `O(N)`이다.)

## 객체 참조 방식으로 표현하기

각 노드를 Node Class의 instance로 선언하고, 각 instace의 attribute로 왼쪽 자식 노드와 오른쪽 자식 노드를 참조할 수 있는 변수를 선안한 후, 각 attribute에 왼쪽/오른쪽 자식 노드의 instance를 할당하여 해당 노드를 참조할 수 있게끔 구현하는 방식이다.

배열과 같이 낭비되는 메모리를 낭비하는 구현방식은 아니지만, 구현 난이도가 배열보다는 높은 편이다. 

```python
class Node:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None 
```
위와 같은 방식으로 노드의 클래스를 표현할 수 있다.

이를 활용해서 Binary Tree를 표현하면 다음과 같다.

```python
class BinaryTree:
    def __init__(self, root:Node):
        self.root = root
    
tree = BinaryTree(Node('A'))
tree.root.left = Node('B')
tree.root.right = Node('C')
...
```

이런 방식으로 포인터라는 개념을 사용할 수 없는 python에서 c/c++과 같은 포인터를 활용한 자료구조를 객체 참조 방식으로 구현할 수 있다.

## 이진 트리 순회하기

이진 트리를 순회하는 방법은 현재 노드의 방문 순서에 따라 크게 다음 3가지 방식이 존재한다.

1. 전위 순회 (preorder) : 현재 노드를 가장 나중에 방문
    - 부모 노드 -> 왼쪽 자식 노드 -> 오른쪽 자식 노드
2. 중위 순회 (inoder) : 왼쪽 자식 노드 우선 탐색 후, 현재 노드 방문
    - 왼쪽 자식 노드 -> 부모 노드 -> 오른쪽 자식 노드
3. 후위 순회 (postorder) : 왼쪽 자식노드와 오른쪽 자식 노드를 모드 탐색 후, 현재 노드 방문
    - 왼쪽 자식 노드 -> 오른쪽 자식 노드 -> 부모 노드

# 이진 트리 탐색하기

이진 트리에서 가장 중요한 것은 **"탐색을 효율적으로 수행할 수 있도록 트리를 구축"**하는 것이다.

## 이진 탐색 트리 (Binary Search Tree) 구축하기

> 이진 탐색 트리 : 데이터 크기를 따져, 본인보다 크기가 작으면 왼쪽 자식 노드에, 크거나 같으면 오른쪽 자식 위치에 배치하는 정렬 방식을 취함

## 이진 탐색 트리 탐색하기

이진 탐색트리를 탐색하는 방법은 다음과 같다.

```
1. 찾으려는 값이 현재 노드의 값과 같으면 탐색 종료
2. 찾으려는 값이 현재 노드의 값보다 크면 오른쪽 노드로 이동
3. 찾으려는 값이 현재 노드의 값보다 작으면 왼쪽 노드로 이동
4. 노드가 없을 때 까지 계속 탐색했는데 값이 없으면 현재 트리에 값이 없는 것.
```

### 배열 탐색과의 효율성 비교

배열의 경우 원하는 값이 나올 떄까지 배열을 앞에서부터 순서대로 모두 방문하여 원하는 값이 나올 떄까지 순회한다. 배열을 정렬해두지 않는 이상, 배열에서 값을 기준으로 효율적으로 원하는 값을 찾는 방법은 없다.

하지만, 이진 탐색 트리의 경우 구축할 떄 값을 기준으로 크면 오른쪽, 작으면 왼쪽으로 탐색할 수 있도록 구축해두었기 때문에, 탐색하지 않아도 되는 대상을 크게 줄일 수 있다.

> 모든 탐색 알고리즘에서 탐색 효율을 개선하는 방법이 그러하듯이, 탐색 대상이 아닌 노드를 한 번에 많이 제외할 수 있기 때문이다.

### 이진 탐색 트리의 시간 복잡도

균형이 유지된 이진 탐색트리 : O(logN)
균형을 이루지 않은 탐색트리 : O(N)
