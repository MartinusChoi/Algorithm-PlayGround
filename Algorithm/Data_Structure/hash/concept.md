# 1. Hash의 개념

## Hash란?
> '해시 함수'를 사용해 '변환한 값을 인데스'로 삼아, key와 value를 저장하여 빠른 데이터 탐색을 제공하는 자료구조
- 모든 자료를 처음부터 모두 살펴봐야하는 숫자 인덱스보다 빠른 데이터 탐색 제공

해시 함수 : `key`를 일정한 hash `value`로 변환시켜 값을 찾을 수 있도록 하는 함수

<br>

## Hash의 특징

### 1. Hash는 단방향으로 동작함
> 키를 통해 값을 찾을 수 있지만, 값을 통해 키를 찾을 수는 없음

### 2. 찾고자 하는 값을 `O(1)` 복잡도로 바로 찾을 수 있음
> 키 자체가 해시 함수를 통해 값이 있는 곳의 인덱스가 되므로, 값을 찾기 위한 탐색 과정이 필요 없음

### 3. 값을 인덱스로 활용하려면 적절한 변환 과정을 거쳐야 함

<br>

## Hash 함수의 의의 (이름으로 전화번호 탐색)

### 1. 해시 함수를 사용하지 않는 경우
> 값의 위치에 대해 어떤 정보도 얻을 수 없으므로 처음부터 모든 값을 탐색해야 함

전화번호 테이블의 제일 처음부터 원하는 이름과 일치하는 지점까지 탐색하여 반환해야 하므로 시간 복잡도는 `O(N)`이 된다

### 2. 해시 함수를 사용하는 경우
> 키가 그 자체로 원하는 값의 인덱스가 되므로 한번에 탐색 완료

사람의 이름을 '해시 함수'로 변환하면 그대로 해당 인물의 전화번호가 저장되어 있는 곳의 인덱스가 되므로 탐색의 시간 복잡도는 `O(1)`이 된다

<br>

## Hash Table과 Bucket

| 명칭 | 의미 |
| :-: | :-: |
| 해시 테이블 (Hash Table) | 키와 대응한 값이 저장되어 있는 공간. 즉, 값들이 저장되어 있는 공간 |
| 버킷 (Bucket) | 해시 테이블의 각 값 |

<br>

## Hash의 특성을 활용하는 분야

> Hash : 단방향 검색을 제공하는 대신, 빠르게 원하는 값을 검색 가능
- 이러한 특성은 데이터를 저장하고 검색하거나, 보안이 필요한 때 활용됨
- **코딩 테스트에서는 특정 데이터를 탐색하는 횟수가 많을 경우 해시를 고려**

1. 비밀번호 관리 : 사용자 비밀번호를 그대로 노출해 저장하는 것은 위험하므로, 해시 함수를 활용해 해싱한 비밀번호 저장
2. 데이터베이스 인덱싱 : DB에 저장된 데이터를 효율적으로 검색
3. 블록체인 : 각 블록은 이전 블록의 해시값을 포함, 이를 통해 데이터 무결성 확인 가능

<br>
<br>

# 2. 해시 함수
> Python에서는 `Dictionary`가 해시와 거의 동일하게 동작함 (직접 해시를 구현할 필요 거의 없음)
- 직접 해시 함수를 구현하는 방법을 알기 위해서는, **해시 함수를 구현할 때 고려할 것을을 알아야 함.**

<br>

## 해시 함수 구현 시 고려할 사항

### 1. 해시 함수가 변환한 값은 해시 테이블의 크기를 넘으면 안됨
- key를 해시 함수에 입력하여 변환한 값은 해시 테이블에서 인덱스로 활용해야하기 때문에 해시 테이블의 크기를 넘는 값으로 변환되면 안됨

### 2. 해시 함수가 변환한 값의 충돌은 최대한 적게 발생해야 함
> 충돌 : 서로 다른 두 key에 대해 '해싱 함수를 적용한 결과가 동일'한 것
서로 다른 key로 접근해 해싱 테이블의 동일한 위치에 저장된다면, 원하지 않은 결과를 초래할 수 있으므로 이를 최소화 해야함
- 실제로 충돌이 아예 발생하지 않는 해시 함수는 거의 존재하지 않음

<br>

## 자주 사용하는 해시 함수들

### 나눗셈법
> key를 소수로 나눈 나머지를 활용하여 해시 테이블에 접근하는 전략

```
h(x) = x mod k
```
- `x`는 키, `k`는 소수를 의미함
- 소수로 나누는 이유 : 다른 수를 사용하여 모듈러 연산(나머지 연산)을 수행할 때보다 충돌이 적기 때문
    - 예시) x가 3의 배수, 15를 k 값으로 사용하는 경우
        - 모듈러 연산 시, 해시값이 3,6,9,12,0 패턴으로 반복됨
        - 즉, 동일한 해시값이 반복되며 충돌이 발생함
- 왜 충돌이 발생하는 가?
    - N의 약수 중 하나를 M이라고 한다면, 임의의 수 K에 대해 `M * K = N`이 되는 K가 반드시 존재함
    - 따라서 K는 1과 자신을 빼고는 약수가 없는 수인 소수를 사용하는 것이 좋다
- 나눗셈범의 해시 테이블 크기는 K이다
    - K는 1과 본인을 제외한 약수가 없기 때문에, key값과 모듈러 연산을 한 나머지는 `0 ~ (K-1)`의 범위를 가지게 됨
    - 따라서 **나눗셈법의 해시 테이블 크기는 K**가 됨

> 알 수 있는 사실 : 해시 테이블의 크기는 해시 함수의 값의 범위에 따른다!

---

### 곱셈법
> 나눗셈법과 비슷하게 모듈러 연산을 활용하지만 소수를 활용하지 않음

```
h(x) = (((x * A) mod 1) * m)
```
- `m`은 최대 버킷의 개수, `A`는 황금비(golden ratio number, 무한소수로 대략 1.6180339877...)
- '나눗셈법'의 경우 저장할 데이터의 크기나 키값의 범위에 따라 큰 소수를 활용해야할 경우가 있는데, 실제로 큰 소수를 구하기 쉽지 않다는 단점이 존재함
- 따라서 이를 보완하기 위해 '곱셈법'이 고안됨

'곱셈법' 해시 함수의 동작은 다음과 같음

**1단계) key에 황금비(0.6183)를 곱함**

```
key * A
```

**2단계) 1단계에서 구한 값의 모듈러 1 연산을 취함**
> 모듈러 1 연산 : 정수 부분을 버리고 소수 부분만 취함
가령, `key * A`의 연산 결과가 3.1523 이었다면, `mod 1` 연산을 통해 0.1523 만 취함

**3단계) 2단계에서 구한 값에 m(해시 테이블 크기)를 곱하여 해시 테이블에 매핑**
> 2단계에서 곱한 값에 len(hash table)값을 곱한 값에서 정수부분만 취한다면 해시 테이블의 인덱스로 활용 가능
- 2단계에서 구한 값이 0.xxx 값이기 때문에 매핑할 테이블의 크기인 m을 곱하면 테이블의 인덱스인 `0~(m-1)` 범위에 매핑할 수 있음

> '곱셈법'은 황금비를 사용하여 필요한 전체 테이블 크기에서 일정 부분에 key를 매핑하므로, '나눗셈법' 처럼 소수가 필요없다. 따라서, 테이블의 크기가 더 커져도 큰 소수를 구해야하는 등 추가 작업이 필요없다

---

### 문자열 해싱

> 앞선 '나눗셈법', '곱셈법'과 달리 key가 문자열이어도 활용 가능한 해싱 함수

> 문자열의 문자를 숫자로 변환하고, 이 숫자들을 다항식의 값으로 변환하여 해싱

```
# polynomial rolling method : 문자열 해싱을 위해 사용하는 함수

hash(s) = (s[0] + s[1]*p + s[2]*p^2 + ... + s[n-1]*p^(n-1)) mod m
```
- `p`는 31, `m`은 해시 테이블 최대 크기
    - p가 31인 이유 : 홀수이며 메르센 소수 이기 때문
    - 메르센 소수 : 일반적으로 `2^N-1`로 표시할 수 있는 숫자 중 소수인 수, 해시에서 충돌을 줄이는데 효과적이라는 연구 결과 존재

문자열 해싱의 동작은 다음과 같음

**1단계) 각 문자를 미리 지정한 논리에 따라 숫자로 변환**

```
string = 'apple'
match_table = {
    'a' : 1,
    'b' : 2,
    ...
    'z' : 26
}
```
- 'a'는 1, 'p'는 16 .. 과 같이 각 문자를 숫자로 변환

**2단계) polynomial rolling method 함수에 따라 해싱 값 연산**

```
1 * (31)^0 + 16 * (31)^1 + ... = 4990970
```

**3단계) 2단계에서 구한 다항식 값의 mod m 연산으로 해싱 테이블에 매핑**

```
hash('apple') = 4990970 % m
```

#### 주의할 점
해시 함수를 적용한 값이 해시 테이블 크기에 비해 너무 클 수 있음
- 앞서 예시에서 간단한 'apple'을 변환했음에도 중간 계산 값이 4990970으로 굉장히 큰 값이 나왔음
이는 오버플로를 발생시킬 여지가 있으므로 다음과 같이 연산 법칙을 활용해 문자열 해시 함수를 수정할 수 있음
```
(a+b)%c = (a%c+b%c)%c
```
따라서, 앞서 활용한 polynomial rolling method를 수정하면 다음과 같음
```
hash(s) = (s[0] % m + s[1]*p % m + s[2]*p^2 % m + ... + s[n-1]*p^(n-1) % m) % m
```

<br>
<br>

# 3. 충돌(collisoin) 처리

충돌이 발생하면 서로 다른 key로 동일한 버킷에 접근하게 됨. 따라서 해시 테이블을 관리할 떄 반드시 충돌 처리를 수행해야 함

<br>

## 체이닝으로 처리하기
> 체이닝 : 충돌 발생 시, 해당 버킷에 링크드리스트로 같은 해시값을 가지는 데이터를 연결함

즉, 동일한 위치에 링크드리스트로 2개 이상의 값을 저장하여 간단하게 충돌을 해결함. 하지만, 다음 2가지 단점이 존재함

### 단점 1 : 해시 테이블 공간 활용성이 떨어짐
> 충돌이 많아지면 그만큼 링크드리스트의 길이가 길어짐과 동시에 해시테이블 공간은 덜 사용하게 되므로, 공간 활용성이 떨어짐

### 단점 2 : 검색 성능이 떨어짐
> 링크드리스트로 연결한 값은 처음부터 탐색해야 하므로, 해시를 사용하는 의의를 저해 함
최악의 경우, 모든 키가 충돌하여 하나의 버킷에 저장되었다면 탐색 시간 복잡도는 `O(N)`이 될 것임

<br>

## 개방 주소법(open addressing)으로 처리하기
> 개방 주소법 : 빈 버킷을 찾아 충돌값을 삽입

이 방법은 해시 테이블을 최대한 활용하므로 '체이닝'보다 메모리를 더 효율적으로 사용함

### 1. 선형 탐사 방식
> 충돌 발생 시, 다른 빈 버킷을 찾을 때까지 일정한 간격(보통 1)으로 이동
```
h(k,i) = (h(k) + i) mod m
```
- `m`은 해시 테이블 크기
- 선형 탐사 시 테이블 범위를 넘으면 안되므로 모듈러 연산을 적용함

#### 선형 탐사 방식의 단점
충돌 발생 시 1칸이 이동하며 해시 테이블 빈 곳에 값을 넣는 것을 반복하면, 충돌이 발생한 값끼지 모이는 영역이 생김(클러스터를 형성하게 됨)
- 이렇게 군집이 생기면 해시값은 충돌할 가능성이 더욱 높아진다

### 2. 이중 해싱 방식
> 해시 함수를 2개 활용하는 것. (경우에 따라 해시 함수를 N개로 늘리기도 함)

두 번째 해시함수의 역할 : 첫 번째 해시 함수로 충돌 발생 시, 해당 위치를 기준으로 어떻게 위치를 정할 지 결정

```
h(k, i) = (h1(k) + i*h2(k)) mod m
```
- 선형 탐사와 비슷하게 특정 값을 더하는 방식으로 데이터의 위치를 정하지만, 클러스터를 줄이기 위해 `m`을 제곱수 혹은 소수로 선정함
    - 이는 주어지는 key마다 점프하는 위치를 해시 함수로 다르게 하여 클러스터 형성을 최대한 피하기 위함