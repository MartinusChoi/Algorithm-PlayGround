# 1. '집합'과 '상호배타적 집합'의 개념

## '집합'의 개념

> 순서와 중복이 없는 원소들을 갖는 자료구조

## '상호 배타적 집합'

> 교집합이 없는 집합의 관계를 의미

## '상호 배타적 집합'을 활용하는 문제

### 1. 그래프 알고리즘

그래프 알고리즘에서 사이클을 확인할 때 '상호 배타적 집합'의 개념을 활용

### 2. 최소 신장 트리 알고리즘 구현

최소 신장 트리 알고리즘 구현시 간선을 추가할 때 마다 사이클을 형성하는 지 여부 확인 시 사용

---

# 2. 집합의 연산

> 보통 집합은 '트리'로 표현함

> 대표적인 집합 연산 : 합치기, 탐색

## 배열을 활용한 트리로 집합 표현

### 대표 원소

> 집합의 원소 중 집합을 대표하는 역할

트리로 집합을 표현할 시 트리의 노드가 해당 집합의 대표 원소가 된다.

### 배열로 집합을 표현하기

배열로 집합을 표현한다는 것은, 하나의 배열로 상호 배타적 관계를 가지는 집합을 모두 표현한다는 것을 의미한다. 즉, 하나의 배열에 모든 상호배타적 집합이 들어가도록 표현한다.

> 핵심 : (배열의 인덱스 -> 자신), (배열의 값 -> 부모 노드) 를 의미한다.

가령 disjoint_set[3] = 9 이면, 노드 3의 부모 노드가 9임을 의미한다.

상호 배타적 관계의 집합은 서로 원소(노드)가 겹치지 않으므로, 하나의 배열 안에 표현할 수 있다.

> 모든 집합의 원소의 개수가 N개인 상호배타적 집합들을 배열로 표현하기 위해서는, N+1 길이의 배열에 표현해야한다.

배열의 인덱스는 0부터 시작하지만, 통상 집합은 1번 원소(노드)부터 시작하기 때문이다.

## 집합 표현 완벽 정리

### 하나의 배열로 나타낸 상호배타적 집합들의 특성

1. 각 집합의 로트 노드는 '인덱스'와 '배열의 해당 인덱스 값'이 같다.
    - 즉, 자신의 부모 노드가 자기 자신으로 표현된다.
2. `disjoint_set[i] = j` 는 `Node i`의 부모 노드가 `Node j`라는 것을 의미한다.
    - `disjoint_set[i] = j`, `disjoint_set[j] = j` 이면, `Node i`는 `Node j`를 루트(대표원소)로 가지는 집합의 원소라고 말할 수 있다.

## 배열로 집합 구현하기

### 1. 초기 상태

- 각 노드는 자기 자신을 루트 노드로 설정
- 집합에 없는 인덱스의 값은 -1

```python
# 집합의 원소 : 1, 2, 3, 4, 5, 8, 9
#        인덱스 : 0  1  2  3  4  5   6   7  8  9
disjoint_set = [-1, 1, 2, 3, 4, 5, -1, -1, 8, 9]
```

### 2. 상호배타적 집합을 표현

- 탐색 : 9 -> 3 -> 2 -> 1

```python
#      집합 A               집합 B             
#        1                   4
#      /   \                /
#     5     2              8
#          /
#         3
#         |
#         9
#                  루트      루트
disjoint_set = [-1, 1, 1, 2, 4, 1, -1, -1, 4, 3]
# 인덱스          0  1  2  3  4  5   6   7  8  9
```

## 유니온-파인드 알고리즘

집합 알고리즘에 주로 쓰이는 연산 : '합치기(Union)' 와 '탐색(Find)'
- 즉, 이 둘을 묶어 'Union-Find' 알고리즘 이라고 함

### 파인드(Find, 탐색) 연산

> 특정 노드의 루트 노드가 무엇인지 탐색하는 방법

보통 '파인드 연산'은 특정 노드가 같은 집합에 있는 지 확인할 때 사용한다. 노드 A와 B가 서로 같은 루트 노드를 가진다면, 이 두 노드는 같은 집합 안에 속한다고 판단한다.

#### 파인트 연산 과정

1. 현재 노드의 부모 노드 확인
    - 부모 노드를 확인하다가 부모 노드가 루트 노드이면 찾기 연산 종료
2. 1에서 찾기 연산이 종료되지 않으면 1을 반복

위의 과정을 재귀함수로 구현한다. 탐색 깊이가 1000을 넘지 않으면 RecursionError가 발생하지 않는다.

#### '경로 압축'으로 파인드 연산 효율화 하기

> 효율적인 파인드 연산을 위해서는, '집합의 형태를 유지'하면서도 '트리 높이를 줄이면' 된다.

만약 다음의 좌측과 같은 트리가 있다면, 우측의 트리와 같이 깊이를 줄일 수 있다.

```
                1                              1
                |                           /  |  \
                2                          2   3   4
                |
                3
                |
                4
```

즉, 루트가 같은 원소(노드)의 부모를 직접 루트와 연결하면 깊이가 짧아져 한번에 루트를 찾을 수 있다.

#### 유니온(Union, 합치기) 연산

> 두 집합을 하나로 합치는 연산. 즉, 두 집합의 루트 노드를 같게 만드는 것.

이 때, 루트 노드는 두 집합의 루트 노드 중 하나가 되면 된다. 이를 정리하면 다음과 같다.

1. 두 집합에서 찾기 연산을 통해 루트 노드 찾기
2. 찾은 두 루트 노드의 값을 비교
    - 다르면 3 수행
3. 두 집합을 합침 -> 두 루트 노드 중 어느 것으로 설정해도 무방
    - 어느 한 루트의 부모가 다른 루트를 부모로 가지면 됨

#### '랭크'로 유니온 연산 효율화 하기

> 랭크 : 현재 노드를 기준으로 했을 때 가장 깉은 노드까지의 경로 길이

'랭크'를 기반으로 유니온 연산을 수행하는 과정은 다음과 같이 정리된다.

1. 두 노드의 루트 노드를 구한다.
2. `1.` 에서 구한 루트 노드의 랭크를 비교
    1. 랭크 값이 다르면,
        - 랭크가 큰 루트 노드를 랭크가 작은 루트 노드의 부모 노드로 바꾼다. -> 트리가 더 깊어지지 않으므로 랭크는 변하지 않음
    2. 랭크 값이 같으면,
        - 둘 중 아무 노드를 선택해도 최종 랭크에 1을 더한 값으로 랭크가 설정됨

