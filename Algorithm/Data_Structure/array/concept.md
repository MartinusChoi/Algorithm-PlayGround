# Array (배열)

## 1. Array (배열) 개념
- 인덱스와 값을 일대일 대응해 관리하는 자료구조
- 데이터를 저장하는 모든 공간은 인덱스와 일대일 대응
    - 어떤 위치에 있는 데이터라도 한 번에 접근 가능
- Python `list`
    - 동적으로 크기를 조절할 수 있도록 구현
    - 다른 언어의 배열 긴으을 그대로 사용하며 배열 크기도 가변적
    - 슬라이싱, 삽입, 삭제, 연결 등의 연산을 제공하므로 편리

### 1-1. 배열 선언
> 배열을 선언하는 방법은 **3가지** 존재

#### ① 일반적인 방법
```python
arr = ['a', 'a', 'a', 'a', 'a']
arr = ['a'] * 5
```

#### ② 리스트 생성자 사용
```python
arr = list(range(5))
```

#### ③ 리스트 컴프리헨션 사용
```python
arr = [val for val in range(5)]
```

---

### 1-2. 배열과 차원
> 배열을 2차원 배열, 3차원 배열과 같이 다차원 배열로 사용할 때도 있음. 하지만 컴퓨터 메모리는 1차원 이므로 다차원 배열도 실제로는 1차원 공간에 저장됨. **즉, 배열은 차원과는 무관하게 메모리에 연속 할당됨.**

#### ① 1차원 배열
- 1차원 배열의 모습이 메모리에 할당된 실제 배열의 모습과 같아 이해하기 쉬움. 
- 배열의 각 데이터는 메모리의 낮은 주소에서 높은 주소 방향으로 연이어 할당됨.

    <image src="https://github.com/user-attachments/assets/8f0bd5fe-13c7-4f5d-ae8e-87f5015696df" width="450px"></image>


#### ② 2차원 배열
- 2차원 배열 선언하기
    ```python
    # 일반적인 선언 방법
    arr = [[1,2,3,4], [1,2,3,4], [1,2,3,4]]

    # 리스트 컴프리헨션
    arr = [[i] * 4 for i in range(3)]
    ```
- 이해를 돕기 위해 2차원 배열을 아래의 왼쪽 그림처럼 표현하는 경우가 많으나, **실제로는 0행, 1행 순서로 데이터를 할당해 1차원 공간에 저장함.**

    <image src="https://github.com/user-attachments/assets/186b04dc-20c2-4b6a-8ef4-c31cfad68f61" width="450px"></image>

---

## 2. 배열의 효율성
> **시간 복잡도** 의 측면에서 배열의 효율성을 판단

### 2-1. 배열 연산의 시간 복잡도

#### ① 데이터 접근
- 배열은 '임의 접근' 이라는 방법으로 배열의 모든 위치에 있는 데이터에 곧바로 접근 가능
- 따라서, 데이터 접근하기 위한 시간 복잡도는 `O(1)` 임.
    - '데이터 삭제'의 경우에도 동일.

#### ② 배열 마지막에 삽입
- 배열의 마지막 위치에 곧바로 접근할 수 있음
- 삽입 과정에서 다른 데이터의 위치에 영향을 주지 않음
- 따라서, 시간 복잡도는 `O(1)` 임

    <image src="https://github.com/user-attachments/assets/82022644-8714-4a4d-a4c9-d99d73a39afe" width="450px"></image>

#### ③ 배열 처음에 삽입
- 배열의 맨 앞에 삽입하는 경우, **기존 모든 데이터들을 뒤로 한 칸씩 밀어야 함.**
- 배열에 저장된 데이터의 수를 N개로 가정한다면, 시간 복잡도는 `O(N)` 이 됨.

    <image src="https://github.com/user-attachments/assets/87a2d26b-7298-4193-8977-330aaeaf0947" width="450px"></image>

#### ④ 배열 중간간에 삽입
- 배열의 중간에 삽입하는 경우, **삽입 위치 이후의 데이터들을 뒤로 한 칸씩 밀어야 함.**
- 삽입 위치 이후의 데이터의 수를 N개로 가정한다면, 시간 복잡도는 `O(N)` 이 됨.

    <image src="https://github.com/user-attachments/assets/1bb7c9ed-549c-4676-af16-c8ca4165fe63" width="450px"></image>

---

### 2-2. 배열을 선택할 때 고려할 점

#### 데이터에 자주 접근하거나 읽어야 하는 경우 좋은 성능을 낼 수 있음
- 예를 들어, 그래프를 표현할 때 배열을 사용하면 임의 접근이 가능하므로 간선 여부도 시간 복잡도 O(1)로 판단할 수 있음
- 즉, **데이터에 빈번하게 접근하는 경우 효율적**

#### 고려할 점
1. **할당할 수 있는 메모리 크기를 확인해야 함.**
    - 배열로 표현하려는 데이터가 너무 많으면 런타임에서 배열 할당에 실패할 수 있음
    - 보통 **정수형** **1차원 배열은 1000만 개**, **2차원 배열은 3000*3000** 크기를 최대로 고려함
2. **중간에 데이터 삽입이 많은지 확인.**
    - 배열은 선형 자료구조이기 떄문에, **중간이나 처음에 데이터를 빈번하게 삽입하면 시간 복잡도가 높아져** 시간 초과 발생 가능

---

## 3. 자주 활용하는 리스트 기법
> 코딩 테스트에서 자주 활용하는 리스트 기법에 대해 정리

### 3-1. 리스트에 데이터 추가

#### ① `append()`
- 리스트 마지막에 데이터 추가
    ```python
    arr = [1, 2, 3]
    arr.append(4)
    ```

#### ② `+` 연산자
- 리스트 마지막에 다른 리스트의 데이터를 추가할 수 있음
    ```python
    arr = [1, 2, 3]
    arr = arr + [4, 5] # [1,2,3,4,5]
    ```

#### ③ `insert()`
- 리스트의 특정 위치에 데이터 삽입
- `insert()`의 첫번째 인자에 **삽입할 데이터의 인덱스 위치**, 두 번째 인자에 **삽입할 데이터**를 받음
    ```python
    arr = [1, 2, 3, 5, 6]
    arr.insert(2, 9999) # [1, 2, 9999, 3, 4, 5]
    ```

---

### 3-2. 리스트에서 데이터 삭제

#### ① `pop()`
- pop할 데이터의 인덱스를 인수로 받아 삭제, 삭제한 데이터의 값을 반환함.
    ```python
    arr = [1, 2, 3, 4, 5]
    popped_element = arr.pop(2)
    
    # popped_element : 3
    # arr : [1, 2, 4, 5]
    ```

#### ② `remove()`
- 특정 위치가 아닌, 특정 데이터 자체를 삭제하는 메서드
- 인수로 받은 값이 처음 등장하는 위치의 데이터를 삭제함
    ```python
    arr = [1, 2, 3, 2, 4, 5]
    arr.remove(2) # [1, 3, 2, 4, 5]
    ```

---

### 3-3. 리스트 컴프리헨션으로 데이터에 특정 연산 적용

#### 예시) 리스트에 제곱 연산 적용
```python
numbers = [1, 2, 3, 4, 5]
squares = [num**2 for num in numbers]
```

---

### 3-4. 리스트 연관 메서드

#### ① `len()`
- 리스트 전체 데이터 개수 반환

#### ② `index()`
- 특정 데이터가 처음 등장한 인덱스 반환
- 없으면 `-1` 반환

#### ③ `sort()`
- 사용자가 정한 기준에 따라 리스트 데이터를 정렬
- 정렬된 값을 반환하지 않고 원본 리스트를 정렬함

#### ④ `count()`
- 특정 데이터의 개수 반환

```python
fruits = ["apple", "banana", "cherry", "apple", "orange", "banana", "kiwi"]
len(fruits) # 7
fruits.index("banana") # 1
fruits.sort( ) # ["apple", "apple", "banana", "banana", "cherry", "kiwi", "orange"]
fruits.sort(reverse=True)  # 내림차순 정렬
fruits.count("apple") # 2 
```